// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  mysli.web.ui.widget = (function(_super) {
    var disconnect_native, ids_pool, ui;

    __extends(widget, _super);

    ui = mysli.web.ui;

    ids_pool = {};

    function widget(options) {
      widget.__super__.constructor.apply(this, arguments);
      this.native_events = {
        'click': 0,
        'mouse-enter': 0,
        'mouse-leave': 0,
        'mouse-move': 0,
        'mouse-out': 0,
        'mouse-over': 0,
        'mouse-up': 0
      };
      this.events = {
        'click': {},
        'mouse-enter': {},
        'mouse-leave': {},
        'mouse-move': {},
        'mouse-out': {},
        'mouse-over': {},
        'mouse-up': {},
        'busy-change': {},
        'disable-change': {},
        'position-change': {},
        'size-change': {},
        'added': {},
        'removed': {},
        'destroyed': {}
      };
      this.destroyed = false;
      this.elements = [];
      this.busy = false;
      this.id = false;
      this.parent = false;
      this.options = ui.util.merge_options(options, {
        disabled: false
      });
    }


    /*
    Overload event connect, to better handle native events (like mouse events)
    @param  {string}   event name
    @param  {function} callback
    @return {string}   id
     */

    widget.prototype.connect = function(event, callback) {
      var dom_event, id, _, _ref;
      id = widget.__super__.connect.call(this, event, callback);
      _ref = this.extract_event_name(event), event = _ref[0], _ = _ref[1];
      if (typeof this.native_events[event] !== 'undefined') {
        this.native_events[event]++;
        if (this.native_events[event] === 1) {
          dom_event = event.replace('-', '');
          this.get_element().on(dom_event, this.trigger.bind(this, event));
        }
      }
      return id;
    };


    /*
    Overload event disconnect, to better handle native events
    @param   {string} id full id, or specified unique id (eg *my_id)
    @returns {boolean}
     */

    widget.prototype.disconnect = function(id) {
      var eid, event;
      if (typeof id !== 'object' && id.substr(0, 1) === '*') {
        id = id + "*";
        for (event in this.events) {
          for (eid in this.events[event]) {
            if (eid.substr(0, id.length) === id) {
              disconnect_native(event, this);
              widget.__super__.disconnect.call(this, event, id);
            }
          }
        }
        return true;
      } else {
        if (typeof id !== 'object') {
          event = id.split('--', 2)[0];
        } else {
          event = id[0];
          id = id[1];
        }
        if (typeof this.events[event] !== 'undefined') {
          disconnect_native(event, this);
          return widget.__super__.disconnect.call(this, event, id);
        }
      }
    };


    /*
    Set busy state for the button
    @param {boolean} state
     */

    widget.prototype.set_busy = function(state) {
      if (state === true) {
        if (this.busy) {
          return;
        }
        this.trigger('busy-change', [state]);
        this.busy = new ui.overlay(this.get_element());
        this.connect('destroyed*widget.overlay', this.busy.destroy.bind(this.busy));
        this.connect('position-change*widget.overlay', function(__, position) {
          return this.busy.set_position(position);
        });
        this.connect('size-change*widget.overlay', function(__, size) {
          return this.busy.set_size(size);
        });
        this.busy.set_busy(true);
        return this.busy.show();
      } else {
        this.disconnect('*widget.overlay');
        this.trigger('busy-change', [state]);
        return this.busy = this.busy.destroy();
      }
    };


    /*
    Get busy state for the button
    @returns {mixed} ui.overlay|false
     */

    widget.prototype.get_busy = function() {
      return this.busy;
    };


    /*
    Set disable state
    @param {boolean} state
     */

    widget.prototype.set_disabled = function(state) {
      this.trigger('disable-change', [state]);
      return this.get_element().prop('disabled', state);
    };


    /*
    Get disabled state
    @returns {boolean}
     */

    widget.prototype.get_disabled = function() {
      return this.get_element().prop('disabled');
    };


    /*
    Set main element's position (offset).
    @param {object} {top:int, left:int}
     */

    widget.prototype.set_position = function(position) {
      var element;
      element = this.get_element();
      this.trigger('position-change', [position, !!element]);
      if (element) {
        return element.offset(position);
      }
    };


    /*
    Get main element's positin (offset).
    @returns {object} {top:int, left:int}|false
     */

    widget.prototype.get_position = function() {
      if (typeof this.get_element() === 'object') {
        return this.get_element().offset();
      }
    };


    /*
    Set main element's size.
    @param {object} size {width: int, height: int}
     */

    widget.prototype.set_size = function(size) {
      var element;
      element = this.get_element();
      if (element) {
        if (size.width) {
          element.css('width', size.width);
        }
        if (size.height) {
          element.css('height', size.height);
        }
      }
      return this.trigger('size-change', [size, !!element]);
    };


    /*
    Get main element's size.
    @returns {object} {width: int, height: int}
     */

    widget.prototype.get_size = function() {
      var element;
      element = this.get_element();
      if (element) {
        return {
          width: element.outerWidth(),
          height: element.outerHeight()
        };
      }
    };


    /*
    You can set an ID only once for particular object
    ID must be unique amoung all object.
    @param {string} id
     */

    widget.prototype.set_id = function(id) {
      if (this.id) {
        throw new Error("You cannot change ID once it was set: `" + id + "`");
      }
      if (typeof ids_pool[id] !== 'undefined') {
        throw new Error("Item with such ID already exists: `" + id + "`");
      }
      this.get_element().attr('id', id);
      this.id = id;
      return ids_pool[id] = this;
    };


    /*
    Get ID for this object
    @returns {string} | false if not set
     */

    widget.prototype.get_id = function() {
      return this.id;
    };


    /*
    Get primary DOM element for this widget.
    @returns {object}
     */

    widget.prototype.get_element = function() {
      return this.elements[0];
    };


    /*
    Set parent
    @param {mixed} parent
     */

    widget.prototype.set_parent = function(parent) {
      if (typeof parent === 'string') {
        return this.parent = $(parent);
      } else {
        return this.parent = parent;
      }
    };


    /*
    Get parent element
    @returns {object}
     */

    widget.prototype.get_parent = function() {
      return this.parent;
    };


    /*
    Show (append) an element (and all containing elements) to the parent
    For this to function, parent needs to be DOM element
     */

    widget.prototype.show = function() {
      if (typeof this.parent.append !== 'function') {
        throw new Error('Parent has no function `append`');
      }
      return this.parent.append(this.get_element());
    };


    /*
    Destroy this widget, please note: this will destroy all elements in DOM,
    trigger 'destroy', and clear connected events.
    You still need to manually delete(ref) afer that.
     */

    widget.prototype.destroy = function() {
      var element, event, _i, _len, _ref;
      this.trigger('destroyed');
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        element.remove();
      }
      if (this.id) {
        delete ids_pool[this.id];
      }
      for (event in this.events) {
        this.events[event] = {};
      }
      this.destroyed = true;
      return false;
    };


    /*
    Disconnect native event.
    @param {string} event
     */

    disconnect_native = function(event, context) {
      var dom_event;
      if (typeof context.native_events[event] !== 'undefined') {
        context.native_events[event]--;
        if (context.native_events[event] === 0) {
          dom_event = event.replace('-', '');
          return context.get_element().off(dom_event);
        }
      }
    };

    return widget;

  })(mysli.web.ui.event);

}).call(this);
