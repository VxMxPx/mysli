#!/usr/bin/php
<?php

namespace Mysli;

class DotBasic
{
    protected $command;
    protected $arguments;
    protected $libpath;

    public function __construct($libpath, array $arguments)
    {
        $this->libpath = rtrim($libpath, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        $this->command = isset($arguments[1]) ? strtolower($arguments[1]) : false;
        $this->arguments = array_slice($arguments, 2);
    }

    public function exec()
    {
        if (!$this->command || !in_array($this->command, ['create', 'open'])) {
            $this->intro();
        } else {
            if ($this->command === 'create') {
                if (count($this->arguments) !== 3) {
                    $arguments = $this->create_interactive();
                } else {
                    $arguments = $this->arguments;
                }
                $this->create($arguments[0], $arguments[1], $arguments[2]);
            } elseif ($this->command === 'open') {
                if (count($this->arguments) !== 2) {
                    $arguments = $this->open_interactive();
                } else {
                    $arguments = $this->arguments;
                }
                $this->open($arguments[0], $arguments[1]);
            }
        }
    }

    public function to_camelcase($string, $uc_first=true)
    {
        // Convert _
        if (strpos($string, '_') !== false) {
            $string = str_replace('_', ' ', $string);
            $string = ucwords($string);
            $string = str_replace(' ', '', $string);
        }

        // Convert backslashes
        if (strpos($string, '\\') !== false) {
            $string = str_replace('\\', ' ', $string);
            $string = ucwords($string);
            $string = str_replace(' ', '\\', $string);
        }

        // Convert slashes
        if (strpos($string, '/') !== false) {
            $string = str_replace('/', ' ', $string);
            $string = ucwords($string);
            $string = str_replace(' ', '/', $string);
        }

        if (!$uc_first) {
            $string = lcfirst($string);
        }
        else {
            $string = ucfirst($string);
        }

        return $string;
    }

    public function find_core()
    {
        $vendors = scandir($this->libpath);
        $cores   = [];
        if (!is_array($vendors)) {
            Dot::error('No libraries in folder: ' . $this->libpath);
            exit(__LINE__);
        }
        foreach ($vendors as $vendor) {
            if (substr($vendor, 0, 1) === '.') continue;
            if (!is_dir($this->libpath . $vendor)) continue;
            $libraries = scandir($this->libpath . $vendor);
            if (!is_array($libraries)) continue;
            foreach ($libraries as $library) {
                if ($library === 'core') {
                    $cores[] = $vendor . '/' . $library;
                }
            }
        }

        return $cores;
    }

    protected function resolve_path($path)
    {
        // We're dealing with absolute path
        if (substr($path, 1, 1) !== ':' && substr($path, 0, 1) !== '/') {
            $path = $this->libpath . ltrim($path, '\\/');
        }

        $existing  = '/';
        $segments  = explode(DIRECTORY_SEPARATOR, $path);
        foreach ($segments as $key => &$segment) {
            if (!is_dir(realpath($existing . $segment))) {
                break;
            }
            $existing = realpath($existing . $segment) . DIRECTORY_SEPARATOR;
            unset($segments[$key]);
        }
        return [$existing, implode('/', $segments)];
    }

    protected function get_path()
    {
        $outpath = '';
        Dot::input('>> ', function ($path) use (&$outpath) {
            $path = $this->resolve_path($path);
            if (!$path[0]) {
                Dot::warn('Invalid path!');
                return false;
            }
            // if (!is_dir($path)) {
            //     Dot::warn('Needs to be directory!');
            //     return false;
            // }
            if (!$path[1] && count(scandir($path[0])) > 2) {
                Dot::warn('The directory is not empty, all data will be erased.');
                $answer = Dot::input('Continue? [Y/n] ', function ($input) {
                    if (in_array(strtolower($input), ['y', 'n']) || empty($input) ) {
                        return true;
                    }
                });
                if (strtolower($answer['last']) === 'n') {
                    return false;
                }
            } elseif ($path[1]) {
                Dot::warn('The directory will be created: ' . $path[1]);
            }
            $outpath = $path[1] ? implode('', $path) : $path[0];
            return true;
        });
        return $outpath;
    }

    public function open_ineractive() {}

    public function create_interactive()
    {
        // Select core
        $cores = $this->find_core();
        Dot::nl();
        Dot::plain('Please enter the number of core you want to use.');
        array_walk($cores, function ($value, $k) {
            Dot::plain($k . ': ' . $value);
        });
        Dot::plain('Default is [0]: ' . $cores[0]);
        $core = '';
        Dot::input('>> ', function ($input) use ($cores, &$core) {
            if (empty($input)) $input = 0;
            if (isset($cores[$input])) {
                $core = $cores[$input];
                return true;
            } else {
                Dot::warn('Invalid entry: ' . $input);
                return false;
            }
        });
        Dot::success('You\'ve selected: ' . $core);
        // Enter public path
        Dot::nl();
        Dot::plain('Please enter the absolute public path.');
        Dot::plain('This is the path where _index.html_ and other publicly accessibly files will be saved.');
        Dot::plain('You can enter relative path to the current directory: ' . $this->libpath);
        $pubpath = $this->get_path();
        Dot::success('The selected public path is: ' . $pubpath);
        // Enter data path
        Dot::nl();
        Dot::plain('Please enter the absolute data path.');
        Dot::plain('This is the path where all settings and other sensitive data will be saved.');
        Dot::plain('You can enter relative path to the current directory: ' . $this->libpath);
        $datpath = $this->get_path();
        if (strpos($datpath, $pubpath) !== false || $datpath === $pubpath) {
            Dot::warn('It\'s not recommended for the data path to be the same as ' .
                '(or subdirectory of) of the public path.');
        }
        Dot::success('The selected data path is: ' . $datpath);

        return [$core, $pubpath, $datpath];
    }

    public function open($pubpath, $datpath) {}

    public function create($core, $pubpath, $datpath)
    {
        // Construct core setup
        Dot::plain('Locating setup for core: ' . $core);
        $setup_file = realpath($this->libpath . $core . DIRECTORY_SEPARATOR . 'setup.php');
        if (!file_exists($setup_file)) {
            Dot::error('Cannot find setup file.');
            return false;
        }
        include $setup_file;
        $core_arr = explode('/', $core);
        $class_name = $this->to_camelcase($core_arr[0]) . '\\' . $this->to_camelcase($core_arr[1]) . '\\' . 'Setup';
        if (!class_exists($class_name, false)) {
            Dot::error('Cannot find setup class: ' . $class_name);
            return false;
        }

        Dot::success('Setup class was found: ' . $class_name);
        $setup = new $class_name($pubpath, $this->libpath, $datpath);
        if (!method_exists($setup, 'before_enable')) {
            Dot::error('Method was not found: before_enable');
            return false;
        }

        if ($setup->before_enable()) {
            Dot::success('Core was successfully enabled.');
            return true;
        } else {
            Dot::error('Error when enabling core!');
            return false;
        }
    }

    public function intro()
    {
        Dot::doc(
            'Mysli Project: Command Line Interface',
            'mysli COMMAND [OPTIONS]...',
            [
                'create' => [
                    "Will create new mysli project. No arguments for interactive mode.",
                    "Alternative usage: mysli create CORE_LIBRARY PUBLIC_PATH DATA_PATH",
                ],
                'open'   => [
                    "Open existing mysli project. No arguments for interactive mode.",
                    "Alternative usage: mysli open PUBLIC_PATH DATA_PATH",
                ],
            ]
        );
    }
}

class Dot
{
    /**
     * Capture the cursos - wait for user's input. You must pass in a function,
     * this will run until function returns true.
     * --
     * @param  string   $title The text displayed for input question.
     * @param  function $func  Function to be executed for each input,
     *                         when function returns true, the cursor will be
     *                         released.
     * --
     * @return array    array(
     *                     'title'  => $title,
     *                     'inputs' => array(all inputed values),
     *                     'last'   => the last inputed value,
     *                     'line'   => number of lines
     *                   )
     */
    public static function input($title, $func)
    {
        $shell = array(
            'title'  => $title,
            'inputs' => array(),
            'line'   => 0
        );

        do {
            if (function_exists('readline')) {
                $stdin = readline($shell['title']);
                readline_add_history($stdin);
            }
            else {
                echo $shell['title'];
                $stdin = fread(STDIN, 8192);
            }
            $stdin = trim($stdin);

            $shell['last'] = $stdin;
            $shell['inputs'][] = $stdin;
            $shell['line']++;

        } while(!$func($stdin, $shell));

        return $shell;
    }

    /**
     * Will fill full width of the line with particular character(s).
     * --
     * @param  string $character
     * --
     * @return void
     */
    public static function fill($character)
    {
        $width = (int) exec('tput cols');
        if ($width === 0) { return; }
        $width = floor($width / strlen($character));
        Dot::plain(str_repeat($character, $width));
    }

    /**
     * Print out the message
     * @param  string  $message
     * @param  boolean $new_line
     */
    public static function warn($message, $new_line=true)
        { return self::out('warn', $message, $new_line); }

    public static function error($message, $new_line=true)
        { return self::out('error', $message, $new_line); }

    public static function plain($message, $new_line=true)
        { return self::out('plain', $message, $new_line); }

    public static function success($message, $new_line=true)
        { return self::out('success', $message, $new_line); }

    /**
     * Create a new line
     * @param  integer $num Number of new lines
     */
    public static function nl($num=1)
        { echo str_repeat("\n", (int)$num); }

    /**
     * Create documentation / help for particular command.
     */
    public static function doc($title, $usage, $commands=false)
    {
        Dot::plain($title);
        Dot::nl();
        Dot::plain('  ' . $usage);
        Dot::nl();

        if (!is_array($commands)) { return; }

        // Get longest key, to align with it
        $longest = 0;
        foreach ($commands as $key => $command) {
            if (strlen($key) > $longest) {
                $longest = strlen($key);
            }
        }

        // Print all commands
        Dot::plain('Available options:');
        Dot::nl();
        foreach ($commands as $key => $command) {
            Dot::plain('  ' . (!is_integer($key) ? $key : ' ') . '  ', false);
            if (!is_array($command)) {
                $command = [$command];
            }
            foreach ($command as $k => $command_line) {
                $length = $k > 0 ? $longest + 4 : $longest - strlen($key);
                Dot::plain(str_repeat(" ", $length), false);
                Dot::plain($command_line);
            }
        }
    }

    /**
     * Will print out the message
     * --
     * @param   string  $type
     *                      plain   -- Regular white message
     *                      error   -- Red message
     *                      warn    -- Yellow message
     *                      success -- Green message
     * @param   string  $message
     * @param   boolean $new_line   Should message be in new line
     */
    public static function out($type, $message, $new_line=true)
    {
        switch (strtolower($type))
        {
            case 'error':
                $color = "\x1b[31;01m";
                break;

            case 'warn':
                $color = "\x1b[33;01m";
                break;

            case 'success':
                $color = "\x1b[32;01m";
                break;

            default:
                $color = null;
        }

        echo
            (!is_null($color) ? $color : ''),
            $message,
            "\x1b[39;49;00m";

        if ($new_line)
            { echo "\n"; }

        flush();
    }
}

$dot_basic = new DotBasic(__DIR__, $_SERVER['argv']);
$dot_basic->exec();
